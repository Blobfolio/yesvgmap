/*!
# Yesvgmap: Spec Reference.
*/

// The ATTR and TAGS arrays are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/yesvgmap-spec.rs"));

/// # Event Attributes.
pub(super) static ATTR_EVENT: [&str; 64] = [
	"onabort",
	"onactivate",
	"onbegin",
	"oncancel",
	"oncanplay",
	"oncanplaythrough",
	"onchange",
	"onclick",
	"onclose",
	"oncuechange",
	"ondblclick",
	"ondrag",
	"ondragend",
	"ondragenter",
	"ondragleave",
	"ondragover",
	"ondragstart",
	"ondrop",
	"ondurationchange",
	"onemptied",
	"onend",
	"onended",
	"onerror",
	"onfocus",
	"onfocusin",
	"onfocusout",
	"oninput",
	"oninvalid",
	"onkeydown",
	"onkeypress",
	"onkeyup",
	"onload",
	"onloadeddata",
	"onloadedmetadata",
	"onloadstart",
	"onmousedown",
	"onmouseenter",
	"onmouseleave",
	"onmousemove",
	"onmouseout",
	"onmouseover",
	"onmouseup",
	"onmousewheel",
	"onpause",
	"onplay",
	"onplaying",
	"onprogress",
	"onratechange",
	"onrepeat",
	"onreset",
	"onresize",
	"onscroll",
	"onseeked",
	"onseeking",
	"onselect",
	"onshow",
	"onstalled",
	"onsubmit",
	"onsuspend",
	"ontimeupdate",
	"ontoggle",
	"onunload",
	"onvolumechange",
	"onwaiting",
];

/// # Normalize Attribute Casing.
///
/// If the attribute is known, return it in the correct case, otherwise pass
/// it back as an `Err`.
pub(crate) fn normalize_attr_case(needle: &str) -> Result<&'static str, &str> {
	let needle = needle.trim();

	// Optimize for correctness.
	if let Ok(pos) = ATTR.binary_search(&needle) {
		return Ok(ATTR[pos]);
	}

	// Try a case-insensitive search across the same.
	if let Some(better) = normalize_fallback(needle, ATTR) {
		return Ok(better);
	}

	// Event attributes are uncommon but should be normalized too so we can
	// more easily detect and complain about them later.
	if
		matches!(needle.as_bytes(), [b'O' | b'o', b'N' | b'n', _, ..]) &&
		let Some(better) = normalize_fallback(needle, ATTR_EVENT)
	{
		return Ok(better);
	}

	// Dunno.
	Err(needle)
}

/// # Normalize Casing.
///
/// If the tag is known, return it in the correct case, otherwise pass
/// it back as an `Err`.
pub(crate) fn normalize_tag_case(needle: &str) -> Result<&'static str, &str> {
	let needle = needle.trim();

	// Optimize for correctness.
	if let Ok(pos) = TAGS.binary_search(&needle) {
		return Ok(TAGS[pos]);
	}

	// Punish abnormal weirdness. Haha.
	normalize_fallback(needle, TAGS).ok_or(needle)
}



#[cold]
/// # Fallback Search.
///
/// Look for `needle` in `haystack` case-insensitively, returning it with the
/// preferred casing if found.
fn normalize_fallback<const N: usize>(needle: &str, haystack: [&'static str; N])
-> Option<&'static str> {
	haystack.iter().copied().find(|v| v.eq_ignore_ascii_case(needle))
}



#[cfg(test)]
mod test {
	use super::*;

	#[test]
	fn t_normalize_attr_case() {
		// These should work upper or natural.
		for i in ATTR.iter().copied().chain(ATTR_EVENT.iter().copied()) {
			assert_eq!(
				normalize_attr_case(i),
				Ok(i),
				"Natural attr normalization failed: {i}",
			);

			let upper = i.to_ascii_uppercase();
			assert_eq!(
				normalize_attr_case(&upper),
				Ok(i),
				"Insensitive attr normalization failed: {i}",
			);

			// No known tags end with a Q so should be passed back as-was.
			let wrong = format!("{i}q");
			assert_eq!(
				normalize_attr_case(&wrong),
				Err(wrong.as_str()),
				"Unknown attr normalization failed: {wrong}",
			);
		}
	}

	#[test]
	fn t_normalize_tag_case() {
		// These should work upper or natural.
		for i in TAGS {
			assert_eq!(
				normalize_tag_case(i),
				Ok(i),
				"Natural tag normalization failed: {i}",
			);

			let upper = i.to_ascii_uppercase();
			assert_eq!(
				normalize_tag_case(&upper),
				Ok(i),
				"Insensitive tag normalization failed: {i}",
			);

			// No known tags end with a Q so should be passed back as-was.
			let wrong = format!("{i}q");
			assert_eq!(
				normalize_tag_case(&wrong),
				Err(wrong.as_str()),
				"Unknown tag normalization failed: {wrong}",
			);
		}
	}

	#[test]
	/// # Verify Sort/Unique.
	fn t_sort_dedup() {
		/// # Check sort and dedupe.
		fn check<const N: usize>(set: [&str; N], label: &str) {
			use std::collections::BTreeSet;
			assert!(set.is_sorted(), "BUG: {label} isn't sorted!");
			assert_eq!(
				set.iter().copied().collect::<BTreeSet<&str>>().len(),
				set.len(),
				"BUG: {label} aren't unique.",
			);
		}

		// ATTR and TAGS are both checked at compile time, but it doesn't
		// hurt to check again.
		check(ATTR, "ATTR");
		check(TAGS, "TAGS");
		check(ATTR_EVENT, "ATTR_EVENT");

		// The event attributes should be absent from the main set.
		assert!(
			ATTR_EVENT.iter().all(|e| ! ATTR.contains(e)),
			"BUG: Event attributes are in main list."
		);
	}

	#[test]
	/// # Ensure Known Attributes are "valid".
	fn t_valid_attr() {
		for attr in ATTR {
			assert!(crate::valid_attr(attr), "BUG: invalid attribute {attr}?!");
		}

		// Tags aren't attributes, but they should pass too.
		for tag in TAGS {
			assert!(crate::valid_attr(tag), "BUG: invalid attribute {tag}?!");
		}
	}
}
